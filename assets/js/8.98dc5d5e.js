(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{278:function(t,s,n){t.exports=n.p+"assets/img/1682331849091.58fedaaf.png"},300:function(t,s,n){"use strict";n.r(s);var v=n(11),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"初识nginx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初识nginx"}},[t._v("#")]),t._v(" 初识Nginx")]),t._v(" "),s("p",[t._v("正向代理是"),s("strong",[t._v("代理服务器")]),t._v("作为客户端访问外部网络资源，例如翻墙工具；反向代理是"),s("strong",[t._v("代理服务器")]),t._v("作为服务器端给客户端提高服务。")]),t._v(" "),s("h3",{attrs:{id:"反向代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#反向代理"}},[t._v("#")]),t._v(" 反向代理")]),t._v(" "),s("p",[s("img",{attrs:{src:n(278),alt:"1682331849091"}})]),t._v(" "),s("h3",{attrs:{id:"负载均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[t._v("#")]),t._v(" 负载均衡")]),t._v(" "),s("p",[t._v("反向代理之后至于去哪个服务里面请求数据，就需要负载均衡算法支撑。")]),t._v(" "),s("p",[s("strong",[t._v("常见负载均衡算法：")])]),t._v(" "),s("p",[s("strong",[t._v("1、轮询（Round Robin）算法")])]),t._v(" "),s("p",[t._v("轮询算法是Nginx默认使用的负载均衡算法。该算法会将请求依次分配给每个可用的服务器，直到分配完成后再从头开始分配。该算法简单、公平，适用于服务器性能相当的情况下使用。")]),t._v(" "),s("p",[s("strong",[t._v("2、IP Hash算法")])]),t._v(" "),s("p",[t._v("IP Hash算法根据客户端的IP地址进行Hash运算，然后将Hash值与服务器列表的长度进行取模运算，得到的结果就是要访问的服务器的序号。这种算法可以保证相同的客户端IP地址访问相同的服务器，适用于需要保持会话的应用场景。")]),t._v(" "),s("p",[s("strong",[t._v("3、最少连接数（Least Connections）算法")])]),t._v(" "),s("p",[t._v("最少连接数算法会将请求分配给当前连接数最少的服务器。该算法可以优化服务器的利用率，但是需要对服务器的连接数进行统计，增加了计算量。")]),t._v(" "),s("p",[s("strong",[t._v("4、加权轮询（Weighted Round Robin）算法")])]),t._v(" "),s("p",[t._v("加权轮询算法会根据服务器的权重值进行轮询，权重值越高的服务器会被分配到更多的请求。该算法可以根据服务器性能的差异进行调整，但是需要在配置文件中指定每个服务器的权重值。")]),t._v(" "),s("p",[s("strong",[t._v("5、加权最少连接数（Weighted Least Connections）算法")])]),t._v(" "),s("p",[t._v("加权最少连接数算法会将请求分配给当前连接数和权重值的乘积最小的服务器。该算法结合了最少连接数算法和加权轮询算法的优点，可以根据服务器性能和连接数进行调整。")])])}),[],!1,null,null,null);s.default=_.exports}}]);